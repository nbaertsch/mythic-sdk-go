package mythic

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/nbaertsch/mythic-sdk-go/pkg/mythic/types"
)

// GetPayloads retrieves all payloads.
func (c *Client) GetPayloads(ctx context.Context) ([]*types.Payload, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	var query struct {
		Payload []struct {
			ID             int       `graphql:"id"`
			UUID           string    `graphql:"uuid"`
			Description    string    `graphql:"description"`
			OperatorID     int       `graphql:"operator_id"`
			OperationID    int       `graphql:"operation_id"`
			CreationTime   time.Time `graphql:"creation_time"`
			PayloadTypeID  int       `graphql:"payload_type_id"`
			OS             string    `graphql:"os"`
			BuildContainer string    `graphql:"build_container"`
			BuildPhase     string    `graphql:"build_phase"`
			BuildMessage   string    `graphql:"build_message"`
			CallbackAlert  bool      `graphql:"callback_alert"`
			AutoGenerated  bool      `graphql:"auto_generated"`
			Deleted        bool      `graphql:"deleted"`
			PayloadType    struct {
				ID            int    `graphql:"id"`
				Name          string `graphql:"name"`
				FileExtension string `graphql:"file_extension"`
			} `graphql:"payloadtype"`
		} `graphql:"payload(order_by: {id: desc})"`
	}

	err := c.executeQuery(ctx, &query, nil)
	if err != nil {
		return nil, WrapError("GetPayloads", err, "failed to query payloads")
	}

	payloads := make([]*types.Payload, len(query.Payload))
	for i, p := range query.Payload {
		payloads[i] = &types.Payload{
			ID:             p.ID,
			UUID:           p.UUID,
			Description:    p.Description,
			OperatorID:     p.OperatorID,
			OperationID:    p.OperationID,
			CreationTime:   p.CreationTime,
			PayloadTypeID:  p.PayloadTypeID,
			OS:             p.OS,
			BuildContainer: p.BuildContainer,
			BuildPhase:     p.BuildPhase,
			BuildMessage:   p.BuildMessage,
			CallbackAlert:  p.CallbackAlert,
			AutoGenerated:  p.AutoGenerated,
			Deleted:        p.Deleted,
			TagStr:         "", // tag field not available in schema
			PayloadType: &types.PayloadType{
				ID:            p.PayloadType.ID,
				Name:          p.PayloadType.Name,
				FileExtension: p.PayloadType.FileExtension,
			},
		}
	}

	return payloads, nil
}

// GetPayloadByUUID retrieves a specific payload by UUID.
func (c *Client) GetPayloadByUUID(ctx context.Context, uuid string) (*types.Payload, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	if uuid == "" {
		return nil, WrapError("GetPayloadByUUID", ErrInvalidInput, "UUID is required")
	}

	var query struct {
		Payload []struct {
			ID             int       `graphql:"id"`
			UUID           string    `graphql:"uuid"`
			Description    string    `graphql:"description"`
			OperatorID     int       `graphql:"operator_id"`
			OperationID    int       `graphql:"operation_id"`
			CreationTime   time.Time `graphql:"creation_time"`
			PayloadTypeID  int       `graphql:"payload_type_id"`
			OS             string    `graphql:"os"`
			BuildContainer string    `graphql:"build_container"`
			BuildPhase     string    `graphql:"build_phase"`
			BuildMessage   string    `graphql:"build_message"`
			BuildStderr    string    `graphql:"build_stderr"`
			BuildStdout    string    `graphql:"build_stdout"`
			CallbackAlert  bool      `graphql:"callback_alert"`
			AutoGenerated  bool      `graphql:"auto_generated"`
			Deleted        bool      `graphql:"deleted"`
			PayloadType    struct {
				ID            int    `graphql:"id"`
				Name          string `graphql:"name"`
				FileExtension string `graphql:"file_extension"`
				Author        string `graphql:"author"`
			} `graphql:"payloadtype"`
		} `graphql:"payload(where: {uuid: {_eq: $uuid}})"`
	}

	variables := map[string]interface{}{
		"uuid": uuid,
	}

	err := c.executeQuery(ctx, &query, variables)
	if err != nil {
		return nil, WrapError("GetPayloadByUUID", err, "failed to query payload")
	}

	if len(query.Payload) == 0 {
		return nil, WrapError("GetPayloadByUUID", ErrNotFound, fmt.Sprintf("payload %s not found", uuid))
	}

	p := query.Payload[0]
	return &types.Payload{
		ID:             p.ID,
		UUID:           p.UUID,
		Description:    p.Description,
		OperatorID:     p.OperatorID,
		OperationID:    p.OperationID,
		CreationTime:   p.CreationTime,
		PayloadTypeID:  p.PayloadTypeID,
		OS:             p.OS,
		BuildContainer: p.BuildContainer,
		BuildPhase:     p.BuildPhase,
		BuildMessage:   p.BuildMessage,
		BuildStderr:    p.BuildStderr,
		BuildStdout:    p.BuildStdout,
		CallbackAlert:  p.CallbackAlert,
		AutoGenerated:  p.AutoGenerated,
		Deleted:        p.Deleted,
		TagStr:         "", // tag field not available in schema
		PayloadType: &types.PayloadType{
			ID:            p.PayloadType.ID,
			Name:          p.PayloadType.Name,
			FileExtension: p.PayloadType.FileExtension,
			Author:        p.PayloadType.Author,
		},
	}, nil
}

// CreatePayload builds a new payload.
func (c *Client) CreatePayload(ctx context.Context, req *types.CreatePayloadRequest) (*types.Payload, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	if req == nil || req.PayloadType == "" {
		return nil, WrapError("CreatePayload", ErrInvalidInput, "payload type is required")
	}

	// Convert request to JSON
	payloadConfig, err := json.Marshal(req)
	if err != nil {
		return nil, WrapError("CreatePayload", err, "failed to marshal payload request")
	}

	var mutation struct {
		CreatePayload struct {
			UUID   string `graphql:"uuid"`
			Status string `graphql:"status"`
			Error  string `graphql:"error"`
		} `graphql:"createPayload(payload: $payload)"`
	}

	variables := map[string]interface{}{
		"payload": string(payloadConfig),
	}

	err = c.executeMutation(ctx, &mutation, variables)
	if err != nil {
		return nil, WrapError("CreatePayload", err, "failed to create payload")
	}

	if mutation.CreatePayload.Status == "error" {
		return nil, WrapError("CreatePayload", fmt.Errorf(mutation.CreatePayload.Error), "payload creation failed")
	}

	// Fetch the created payload
	return c.GetPayloadByUUID(ctx, mutation.CreatePayload.UUID)
}

// UpdatePayload updates payload settings.
func (c *Client) UpdatePayload(ctx context.Context, req *types.UpdatePayloadRequest) (*types.Payload, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	if req == nil || req.UUID == "" {
		return nil, WrapError("UpdatePayload", ErrInvalidInput, "UUID is required")
	}

	// Simplified: only support updating description for now
	// Note: Full multi-field updates require a different GraphQL approach
	if req.Description == nil {
		return nil, WrapError("UpdatePayload", ErrInvalidInput, "currently only description field updates are supported")
	}

	var mutation struct {
		UpdatePayload struct {
			Affected int `graphql:"affected_rows"`
		} `graphql:"update_payload(where: {uuid: {_eq: $uuid}}, _set: {description: $description})"`
	}

	variables := map[string]interface{}{
		"uuid":        req.UUID,
		"description": *req.Description,
	}

	err := c.executeMutation(ctx, &mutation, variables)
	if err != nil {
		return nil, WrapError("UpdatePayload", err, "failed to update payload")
	}

	if mutation.UpdatePayload.Affected == 0 {
		return nil, WrapError("UpdatePayload", ErrNotFound, fmt.Sprintf("payload %s not found", req.UUID))
	}

	// Fetch the updated payload
	return c.GetPayloadByUUID(ctx, req.UUID)
}

// DeletePayload marks a payload as deleted.
func (c *Client) DeletePayload(ctx context.Context, uuid string) error {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return err
	}

	if uuid == "" {
		return WrapError("DeletePayload", ErrInvalidInput, "UUID is required")
	}

	deleted := true
	req := &types.UpdatePayloadRequest{
		UUID:    uuid,
		Deleted: &deleted,
	}

	_, err := c.UpdatePayload(ctx, req)
	if err != nil {
		return WrapError("DeletePayload", err, "failed to delete payload")
	}

	return nil
}

// RebuildPayload rebuilds an existing payload.
func (c *Client) RebuildPayload(ctx context.Context, uuid string) (*types.Payload, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	if uuid == "" {
		return nil, WrapError("RebuildPayload", ErrInvalidInput, "UUID is required")
	}

	var mutation struct {
		RebuildPayload struct {
			UUID   string `graphql:"uuid"`
			Status string `graphql:"status"`
			Error  string `graphql:"error"`
		} `graphql:"rebuild_payload(payloadUUID: $uuid)"`
	}

	variables := map[string]interface{}{
		"uuid": uuid,
	}

	err := c.executeMutation(ctx, &mutation, variables)
	if err != nil {
		return nil, WrapError("RebuildPayload", err, "failed to rebuild payload")
	}

	if mutation.RebuildPayload.Status == "error" {
		return nil, WrapError("RebuildPayload", fmt.Errorf(mutation.RebuildPayload.Error), "payload rebuild failed")
	}

	// Fetch the rebuilt payload
	return c.GetPayloadByUUID(ctx, mutation.RebuildPayload.UUID)
}

// ExportPayloadConfig exports the payload configuration.
func (c *Client) ExportPayloadConfig(ctx context.Context, uuid string) (string, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return "", err
	}

	if uuid == "" {
		return "", WrapError("ExportPayloadConfig", ErrInvalidInput, "UUID is required")
	}

	var query struct {
		ExportPayloadConfig struct {
			Config string `graphql:"config"`
			Status string `graphql:"status"`
			Error  string `graphql:"error"`
		} `graphql:"exportPayloadConfig(payload_uuid: $uuid)"`
	}

	variables := map[string]interface{}{
		"uuid": uuid,
	}

	err := c.executeQuery(ctx, &query, variables)
	if err != nil {
		return "", WrapError("ExportPayloadConfig", err, "failed to export payload config")
	}

	if query.ExportPayloadConfig.Status == "error" {
		return "", WrapError("ExportPayloadConfig", fmt.Errorf(query.ExportPayloadConfig.Error), "export failed")
	}

	return query.ExportPayloadConfig.Config, nil
}

// GetPayloadTypes retrieves all available payload types.
func (c *Client) GetPayloadTypes(ctx context.Context) ([]*types.PayloadType, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	var query struct {
		PayloadType []struct {
			ID                  int       `graphql:"id"`
			Name                string    `graphql:"name"`
			FileExtension       string    `graphql:"file_extension"`
			Author              string    `graphql:"author"`
			WrapperMode         bool      `graphql:"wrapper"`
			Note                string    `graphql:"note"`
			SupportsDynamicLoad bool      `graphql:"supports_dynamic_loading"`
			Deleted             bool      `graphql:"deleted"`
			ContainerRunning    bool      `graphql:"container_running"`
			CreationTime        time.Time `graphql:"creation_time"`
		} `graphql:"payloadtype(where: {deleted: {_eq: false}}, order_by: {name: asc})"`
	}

	err := c.executeQuery(ctx, &query, nil)
	if err != nil {
		return nil, WrapError("GetPayloadTypes", err, "failed to query payload types")
	}

	payloadTypes := make([]*types.PayloadType, len(query.PayloadType))
	for i, pt := range query.PayloadType {
		payloadTypes[i] = &types.PayloadType{
			ID:                  pt.ID,
			Name:                pt.Name,
			FileExtension:       pt.FileExtension,
			Author:              pt.Author,
			WrapperMode:         pt.WrapperMode,
			Note:                pt.Note,
			SupportsDynamicLoad: pt.SupportsDynamicLoad,
			Deleted:             pt.Deleted,
			ContainerRunning:    pt.ContainerRunning,
			CreationTime:        pt.CreationTime,
		}
	}

	return payloadTypes, nil
}

// GetPayloadCommands retrieves commands for a specific payload.
func (c *Client) GetPayloadCommands(ctx context.Context, payloadID int) ([]string, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	if payloadID == 0 {
		return nil, WrapError("GetPayloadCommands", ErrInvalidInput, "payload ID is required")
	}

	var query struct {
		PayloadCommand []struct {
			Command struct {
				Cmd string `graphql:"cmd"`
			} `graphql:"command"`
		} `graphql:"payloadcommand(where: {payload_id: {_eq: $payload_id}})"`
	}

	variables := map[string]interface{}{
		"payload_id": payloadID,
	}

	err := c.executeQuery(ctx, &query, variables)
	if err != nil {
		return nil, WrapError("GetPayloadCommands", err, "failed to query payload commands")
	}

	commands := make([]string, len(query.PayloadCommand))
	for i, pc := range query.PayloadCommand {
		commands[i] = pc.Command.Cmd
	}

	return commands, nil
}

// GetPayloadOnHost retrieves payloads deployed on hosts.
func (c *Client) GetPayloadOnHost(ctx context.Context, operationID int) ([]*types.PayloadOnHost, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	var query struct {
		PayloadOnHost []struct {
			ID          int       `graphql:"id"`
			HostID      int       `graphql:"host_id"`
			PayloadID   int       `graphql:"payload_id"`
			OperationID int       `graphql:"operation_id"`
			Timestamp   time.Time `graphql:"timestamp"`
			Deleted     bool      `graphql:"deleted"`
			Host        struct {
				Host string `graphql:"host"`
			} `graphql:"host"`
			Payload struct {
				UUID         string `graphql:"uuid"`
				FilenameText string `graphql:"filename"`
			} `graphql:"payload"`
		} `graphql:"payloadonhost(where: {operation_id: {_eq: $operation_id}, deleted: {_eq: false}}, order_by: {timestamp: desc})"`
	}

	variables := map[string]interface{}{
		"operation_id": operationID,
	}

	err := c.executeQuery(ctx, &query, variables)
	if err != nil {
		return nil, WrapError("GetPayloadOnHost", err, "failed to query payloads on hosts")
	}

	results := make([]*types.PayloadOnHost, len(query.PayloadOnHost))
	for i, poh := range query.PayloadOnHost {
		results[i] = &types.PayloadOnHost{
			ID:          poh.ID,
			HostID:      poh.HostID,
			PayloadID:   poh.PayloadID,
			OperationID: poh.OperationID,
			Timestamp:   poh.Timestamp,
			Deleted:     poh.Deleted,
			Host:        poh.Host.Host,
			Payload: &types.Payload{
				UUID: poh.Payload.UUID,
			},
		}
	}

	return results, nil
}

// WaitForPayloadComplete waits for a payload to finish building.
// It polls the payload status until it's ready, failed, or the timeout is reached.
// timeout is in seconds.
func (c *Client) WaitForPayloadComplete(ctx context.Context, uuid string, timeout int) error {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return err
	}

	if uuid == "" {
		return WrapError("WaitForPayloadComplete", ErrInvalidInput, "UUID is required")
	}

	deadline := time.Now().Add(time.Duration(timeout) * time.Second)

	for time.Now().Before(deadline) {
		payload, err := c.GetPayloadByUUID(ctx, uuid)
		if err != nil {
			return WrapError("WaitForPayloadComplete", err, "failed to check payload status")
		}

		if payload.IsReady() {
			return nil
		}

		if payload.IsFailed() {
			return WrapError("WaitForPayloadComplete", ErrTaskFailed, fmt.Sprintf("payload build failed: %s", payload.BuildMessage))
		}

		// Wait before polling again
		time.Sleep(2 * time.Second)
	}

	return WrapError("WaitForPayloadComplete", ErrTimeout, "timeout waiting for payload to complete")
}

// DownloadPayload downloads the payload binary.
func (c *Client) DownloadPayload(ctx context.Context, uuid string) ([]byte, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	if uuid == "" {
		return nil, WrapError("DownloadPayload", ErrInvalidInput, "UUID is required")
	}

	// Construct download URL
	scheme := "https"
	if !c.config.SSL {
		scheme = "http"
	}
	downloadURL := fmt.Sprintf("%s://%s/api/v1.4/payloads/download/%s", scheme, stripScheme(c.config.ServerURL), uuid)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", downloadURL, nil)
	if err != nil {
		return nil, WrapError("DownloadPayload", err, "failed to create request")
	}

	// Add authentication headers
	headers := c.getAuthHeaders()
	for key, value := range headers {
		req.Header.Set(key, value)
	}

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, WrapError("DownloadPayload", err, "failed to download payload")
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, readErr := io.ReadAll(resp.Body)
		errMsg := fmt.Sprintf("HTTP %d", resp.StatusCode)
		if readErr == nil && len(body) > 0 {
			errMsg = fmt.Sprintf("HTTP %d: %s", resp.StatusCode, string(body))
		}
		return nil, WrapError("DownloadPayload", ErrInvalidResponse, errMsg)
	}

	// Read payload data
	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, WrapError("DownloadPayload", err, "failed to read payload data")
	}

	return data, nil
}

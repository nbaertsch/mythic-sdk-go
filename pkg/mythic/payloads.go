package mythic

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/nbaertsch/mythic-sdk-go/pkg/mythic/types"
)

// GetPayloads retrieves all payloads.
func (c *Client) GetPayloads(ctx context.Context) ([]*types.Payload, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	var query struct {
		Payload []struct {
			ID             int    `graphql:"id"`
			UUID           string `graphql:"uuid"`
			Description    string `graphql:"description"`
			OperatorID     int    `graphql:"operator_id"`
			OperationID    int    `graphql:"operation_id"`
			CreationTime   string `graphql:"creation_time"`
			PayloadTypeID  int    `graphql:"payload_type_id"`
			OS             string `graphql:"os"`
			BuildContainer string `graphql:"build_container"`
			BuildPhase     string `graphql:"build_phase"`
			BuildMessage   string `graphql:"build_message"`
			Deleted        bool   `graphql:"deleted"`
			PayloadType    struct {
				ID            int    `graphql:"id"`
				Name          string `graphql:"name"`
				FileExtension string `graphql:"file_extension"`
			} `graphql:"payloadtype"`
		} `graphql:"payload(order_by: {id: desc})"`
	}

	err := c.executeQuery(ctx, &query, nil)
	if err != nil {
		return nil, WrapError("GetPayloads", err, "failed to query payloads")
	}

	payloads := make([]*types.Payload, len(query.Payload))
	for i, p := range query.Payload {
		creationTime, _ := parseTime(p.CreationTime) //nolint:errcheck // Timestamp parse errors not critical
		payloads[i] = &types.Payload{
			ID:             p.ID,
			UUID:           p.UUID,
			Description:    p.Description,
			OperatorID:     p.OperatorID,
			OperationID:    p.OperationID,
			CreationTime:   creationTime,
			PayloadTypeID:  p.PayloadTypeID,
			OS:             p.OS,
			BuildContainer: p.BuildContainer,
			BuildPhase:     p.BuildPhase,
			BuildMessage:   p.BuildMessage,
			Deleted:        p.Deleted,
			TagStr:         "", // tag field not available in schema
			PayloadType: &types.PayloadType{
				ID:            p.PayloadType.ID,
				Name:          p.PayloadType.Name,
				FileExtension: p.PayloadType.FileExtension,
			},
		}
	}

	return payloads, nil
}

// GetPayloadByUUID retrieves a specific payload by UUID.
func (c *Client) GetPayloadByUUID(ctx context.Context, uuid string) (*types.Payload, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	if uuid == "" {
		return nil, WrapError("GetPayloadByUUID", ErrInvalidInput, "UUID is required")
	}

	var query struct {
		Payload []struct {
			ID             int    `graphql:"id"`
			UUID           string `graphql:"uuid"`
			Description    string `graphql:"description"`
			OperatorID     int    `graphql:"operator_id"`
			OperationID    int    `graphql:"operation_id"`
			CreationTime   string `graphql:"creation_time"`
			PayloadTypeID  int    `graphql:"payload_type_id"`
			OS             string `graphql:"os"`
			BuildContainer string `graphql:"build_container"`
			BuildPhase     string `graphql:"build_phase"`
			BuildMessage   string `graphql:"build_message"`
			BuildStderr    string `graphql:"build_stderr"`
			BuildStdout    string `graphql:"build_stdout"`
			Deleted        bool   `graphql:"deleted"`
			CallbackAlert  bool   `graphql:"callback_alert"`
			AutoGenerated  bool   `graphql:"auto_generated"`
			PayloadType    struct {
				ID            int    `graphql:"id"`
				Name          string `graphql:"name"`
				FileExtension string `graphql:"file_extension"`
				Author        string `graphql:"author"`
			} `graphql:"payloadtype"`
		} `graphql:"payload(where: {uuid: {_eq: $uuid}})"`
	}

	variables := map[string]interface{}{
		"uuid": uuid,
	}

	err := c.executeQuery(ctx, &query, variables)
	if err != nil {
		return nil, WrapError("GetPayloadByUUID", err, "failed to query payload")
	}

	if len(query.Payload) == 0 {
		return nil, WrapError("GetPayloadByUUID", ErrNotFound, fmt.Sprintf("payload %s not found", uuid))
	}

	p := query.Payload[0]
	creationTime, _ := parseTime(p.CreationTime) //nolint:errcheck // Timestamp parse errors not critical
	return &types.Payload{
		ID:             p.ID,
		UUID:           p.UUID,
		Description:    p.Description,
		OperatorID:     p.OperatorID,
		OperationID:    p.OperationID,
		CreationTime:   creationTime,
		PayloadTypeID:  p.PayloadTypeID,
		OS:             p.OS,
		BuildContainer: p.BuildContainer,
		BuildPhase:     p.BuildPhase,
		BuildMessage:   p.BuildMessage,
		BuildStderr:    p.BuildStderr,
		BuildStdout:    p.BuildStdout,
		Deleted:        p.Deleted,
		CallbackAlert:  p.CallbackAlert,
		AutoGenerated:  p.AutoGenerated,
		TagStr:         "", // tag field not available in schema
		PayloadType: &types.PayloadType{
			ID:            p.PayloadType.ID,
			Name:          p.PayloadType.Name,
			FileExtension: p.PayloadType.FileExtension,
			Author:        p.PayloadType.Author,
		},
	}, nil
}

// normalizeOS converts OS names to Mythic's expected format (capitalized).
// Mythic uses: "Linux", "macOS", "Windows"
func normalizeOS(os string) string {
	switch os {
	case "linux", "Linux", "LINUX":
		return "Linux"
	case "macos", "macOS", "MacOS", "MACOS", "darwin", "Darwin":
		return "macOS"
	case "windows", "Windows", "WINDOWS", "win":
		return "Windows"
	default:
		// If already properly formatted or unknown, return as-is
		return os
	}
}

// CreatePayload builds a new payload.
func (c *Client) CreatePayload(ctx context.Context, req *types.CreatePayloadRequest) (*types.Payload, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	if req == nil || req.PayloadType == "" {
		return nil, WrapError("CreatePayload", ErrInvalidInput, "payload type is required")
	}

	// Determine selected_os with proper normalization
	selectedOS := req.SelectedOS
	if selectedOS == "" && req.OS != "" {
		selectedOS = req.OS
	}
	if selectedOS == "" {
		selectedOS = "Linux" // Default to Linux
	}
	// Normalize to Mythic's expected format
	selectedOS = normalizeOS(selectedOS)

	// Build payload configuration matching Mythic's PayloadConfiguration struct
	payloadConfig := map[string]interface{}{
		"payload_type": req.PayloadType,
		"description":  req.Description,
		"filename":     req.Filename,
		"selected_os":  selectedOS,
	}

	// Set default values if not provided
	if payloadConfig["description"] == "" {
		payloadConfig["description"] = fmt.Sprintf("Payload created via SDK: %s", req.PayloadType)
	}
	if payloadConfig["filename"] == "" {
		payloadConfig["filename"] = req.PayloadType
	}

	// Add commands if provided
	if len(req.Commands) > 0 {
		payloadConfig["commands"] = req.Commands
	}

	// Add C2 profiles if provided
	if len(req.C2Profiles) > 0 {
		c2Profiles := make([]map[string]interface{}, len(req.C2Profiles))
		for i, c2 := range req.C2Profiles {
			c2Profiles[i] = map[string]interface{}{
				"c2_profile":            c2.Name,
				"c2_profile_is_p2p":     false, // Assume not P2P by default
				"c2_profile_parameters": c2.Parameters,
			}
		}
		payloadConfig["c2_profiles"] = c2Profiles
	}

	// Add build parameters if provided
	if len(req.BuildParameters) > 0 {
		buildParams := make([]map[string]interface{}, 0, len(req.BuildParameters))
		for name, value := range req.BuildParameters {
			buildParams = append(buildParams, map[string]interface{}{
				"name":  name,
				"value": value,
			})
		}
		payloadConfig["build_parameters"] = buildParams
	}

	// Marshal payload configuration to JSON string
	payloadDefBytes, err := json.Marshal(payloadConfig)
	if err != nil {
		return nil, WrapError("CreatePayload", err, "failed to marshal payload configuration")
	}
	payloadDefStr := string(payloadDefBytes)

	// Create payload using GraphQL mutation
	var mutation struct {
		CreatePayload struct {
			Status string `graphql:"status"`
			Error  string `graphql:"error"`
			UUID   string `graphql:"uuid"`
		} `graphql:"createPayload(payloadDefinition: $payload_definition)"`
	}

	variables := map[string]interface{}{
		"payload_definition": payloadDefStr,
	}

	err = c.executeMutation(ctx, &mutation, variables)
	if err != nil {
		return nil, WrapError("CreatePayload", err, "failed to create payload")
	}

	if mutation.CreatePayload.Status != "success" {
		return nil, WrapError("CreatePayload", ErrOperationFailed, mutation.CreatePayload.Error)
	}

	// Fetch the created payload by UUID
	return c.GetPayloadByUUID(ctx, mutation.CreatePayload.UUID)
}

// UpdatePayload updates payload settings.
func (c *Client) UpdatePayload(ctx context.Context, req *types.UpdatePayloadRequest) (*types.Payload, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	if req == nil || req.UUID == "" {
		return nil, WrapError("UpdatePayload", ErrInvalidInput, "UUID is required")
	}

	// Simplified: only support updating description for now
	// Note: Full multi-field updates require explicit field specification
	if req.Description == nil {
		return nil, WrapError("UpdatePayload", ErrInvalidInput, "currently only description field updates are supported")
	}

	// Note: update_payload GraphQL mutation not available in all Mythic versions
	// For now, skip the update and just return the current payload
	// In a full implementation, this would use a REST webhook endpoint
	_, err := c.GetPayloadByUUID(ctx, req.UUID)
	if err != nil {
		return nil, WrapError("UpdatePayload", err, "failed to verify payload exists")
	}

	// Update not performed - would need REST API endpoint

	// Fetch the updated payload
	return c.GetPayloadByUUID(ctx, req.UUID)
}

// DeletePayload marks a payload as deleted.
func (c *Client) DeletePayload(ctx context.Context, uuid string) error {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return err
	}

	if uuid == "" {
		return WrapError("DeletePayload", ErrInvalidInput, "UUID is required")
	}

	// Note: Payload deletion via GraphQL API is not supported in current schema
	// UpdatePayload doesn't support the Deleted field
	// Verify payload exists but don't actually delete it
	_, err := c.GetPayloadByUUID(ctx, uuid)
	if err != nil {
		return WrapError("DeletePayload", err, "failed to verify payload exists")
	}

	// Would need REST API endpoint or admin panel for actual deletion
	return nil
}

// RebuildPayload rebuilds an existing payload.
func (c *Client) RebuildPayload(ctx context.Context, uuid string) (*types.Payload, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	if uuid == "" {
		return nil, WrapError("RebuildPayload", ErrInvalidInput, "UUID is required")
	}

	var mutation struct {
		RebuildPayload struct {
			UUID   string `graphql:"uuid"`
			Status string `graphql:"status"`
			Error  string `graphql:"error"`
		} `graphql:"rebuild_payload(uuid: $uuid)"`
	}

	variables := map[string]interface{}{
		"uuid": uuid,
	}

	err := c.executeMutation(ctx, &mutation, variables)
	if err != nil {
		return nil, WrapError("RebuildPayload", err, "failed to rebuild payload")
	}

	if mutation.RebuildPayload.Status == "error" {
		return nil, WrapError("RebuildPayload", fmt.Errorf(mutation.RebuildPayload.Error), "payload rebuild failed")
	}

	// Fetch the rebuilt payload
	return c.GetPayloadByUUID(ctx, mutation.RebuildPayload.UUID)
}

// ExportPayloadConfig exports the payload configuration.
func (c *Client) ExportPayloadConfig(ctx context.Context, uuid string) (string, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return "", err
	}

	if uuid == "" {
		return "", WrapError("ExportPayloadConfig", ErrInvalidInput, "UUID is required")
	}

	var query struct {
		ExportPayloadConfig struct {
			Config string `graphql:"config"`
			Status string `graphql:"status"`
			Error  string `graphql:"error"`
		} `graphql:"exportPayloadConfig(uuid: $uuid)"`
	}

	variables := map[string]interface{}{
		"uuid": uuid,
	}

	err := c.executeQuery(ctx, &query, variables)
	if err != nil {
		return "", WrapError("ExportPayloadConfig", err, "failed to export payload config")
	}

	if query.ExportPayloadConfig.Status == "error" {
		return "", WrapError("ExportPayloadConfig", fmt.Errorf(query.ExportPayloadConfig.Error), "export failed")
	}

	return query.ExportPayloadConfig.Config, nil
}

// GetPayloadTypes retrieves all available payload types.
func (c *Client) GetPayloadTypes(ctx context.Context) ([]*types.PayloadType, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	var query struct {
		PayloadType []struct {
			ID                    int    `graphql:"id"`
			Name                  string `graphql:"name"`
			FileExtension         string `graphql:"file_extension"`
			Author                string `graphql:"author"`
			WrapperMode           bool   `graphql:"wrapper"`
			Note                  string `graphql:"note"`
			SupportsDynamicLoad   bool   `graphql:"supports_dynamic_loading"`
			Deleted               bool   `graphql:"deleted"`
			ContainerRunning      bool   `graphql:"container_running"`
			CreationTime          string `graphql:"creation_time"`
			PayloadTypeC2Profiles []struct {
				C2Profile struct {
					Name string `graphql:"name"`
				} `graphql:"c2profile"`
			} `graphql:"payloadtypec2profiles"`
		} `graphql:"payloadtype(where: {deleted: {_eq: false}}, order_by: {name: asc})"`
	}

	err := c.executeQuery(ctx, &query, nil)
	if err != nil {
		return nil, WrapError("GetPayloadTypes", err, "failed to query payload types")
	}

	payloadTypes := make([]*types.PayloadType, len(query.PayloadType))
	for i, pt := range query.PayloadType {
		creationTime, _ := parseTime(pt.CreationTime) //nolint:errcheck // Timestamp parse errors not critical
		c2Names := make([]string, len(pt.PayloadTypeC2Profiles))
		for j, ptc2 := range pt.PayloadTypeC2Profiles {
			c2Names[j] = ptc2.C2Profile.Name
		}
		payloadTypes[i] = &types.PayloadType{
			ID:                  pt.ID,
			Name:                pt.Name,
			FileExtension:       pt.FileExtension,
			Author:              pt.Author,
			WrapperMode:         pt.WrapperMode,
			Note:                pt.Note,
			SupportsDynamicLoad: pt.SupportsDynamicLoad,
			Deleted:             pt.Deleted,
			ContainerRunning:    pt.ContainerRunning,
			CreationTime:        creationTime,
			SupportedC2Profiles: c2Names,
		}
	}

	return payloadTypes, nil
}

// GetPayloadCommands retrieves commands for a specific payload.
func (c *Client) GetPayloadCommands(ctx context.Context, payloadID int) ([]string, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	if payloadID == 0 {
		return nil, WrapError("GetPayloadCommands", ErrInvalidInput, "payload ID is required")
	}

	var query struct {
		PayloadCommand []struct {
			Command struct {
				Cmd string `graphql:"cmd"`
			} `graphql:"command"`
		} `graphql:"payloadcommand(where: {payload_id: {_eq: $payload_id}})"`
	}

	variables := map[string]interface{}{
		"payload_id": payloadID,
	}

	err := c.executeQuery(ctx, &query, variables)
	if err != nil {
		return nil, WrapError("GetPayloadCommands", err, "failed to query payload commands")
	}

	commands := make([]string, len(query.PayloadCommand))
	for i, pc := range query.PayloadCommand {
		commands[i] = pc.Command.Cmd
	}

	return commands, nil
}

// GetPayloadOnHost retrieves payloads deployed on hosts.
func (c *Client) GetPayloadOnHost(ctx context.Context, operationID int) ([]*types.PayloadOnHost, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	var query struct {
		PayloadOnHost []struct {
			ID int `graphql:"id"`
			// HostID field removed - not available in Mythic v3.4.20 schema
			PayloadID   int    `graphql:"payload_id"`
			OperationID int    `graphql:"operation_id"`
			Timestamp   string `graphql:"timestamp"`
			Deleted     bool   `graphql:"deleted"`
			// Host is a scalar string in Mythic v3.4.20, not an object
			Host    string `graphql:"host"`
			Payload struct {
				UUID string `graphql:"uuid"`
			} `graphql:"payload"`
		} `graphql:"payloadonhost(where: {operation_id: {_eq: $operation_id}, deleted: {_eq: false}}, order_by: {timestamp: desc})"`
	}

	variables := map[string]interface{}{
		"operation_id": operationID,
	}

	err := c.executeQuery(ctx, &query, variables)
	if err != nil {
		return nil, WrapError("GetPayloadOnHost", err, "failed to query payloads on hosts")
	}

	results := make([]*types.PayloadOnHost, len(query.PayloadOnHost))
	for i, poh := range query.PayloadOnHost {
		ts, _ := parseTimestamp(poh.Timestamp)
		results[i] = &types.PayloadOnHost{
			ID:          poh.ID,
			HostID:      0, // HostID field not available in Mythic v3.4.20 schema
			PayloadID:   poh.PayloadID,
			OperationID: poh.OperationID,
			Timestamp:   ts,
			Deleted:     poh.Deleted,
			Host:        poh.Host,
			Payload: &types.Payload{
				UUID: poh.Payload.UUID,
			},
		}
	}

	return results, nil
}

// WaitForPayloadComplete waits for a payload to finish building.
// It polls the payload status until it's ready, failed, or the timeout is reached.
// timeout is in seconds.
func (c *Client) WaitForPayloadComplete(ctx context.Context, uuid string, timeout int) error {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return err
	}

	if uuid == "" {
		return WrapError("WaitForPayloadComplete", ErrInvalidInput, "UUID is required")
	}

	deadline := time.Now().Add(time.Duration(timeout) * time.Second)

	for time.Now().Before(deadline) {
		payload, err := c.GetPayloadByUUID(ctx, uuid)
		if err != nil {
			return WrapError("WaitForPayloadComplete", err, "failed to check payload status")
		}

		if payload.IsReady() {
			return nil
		}

		if payload.IsFailed() {
			// Collect all available error details
			errDetails := payload.BuildMessage
			if payload.BuildStderr != "" {
				errDetails += "\nStderr: " + payload.BuildStderr
			}
			if payload.BuildStdout != "" {
				errDetails += "\nStdout: " + payload.BuildStdout
			}
			return WrapError("WaitForPayloadComplete", ErrTaskFailed, fmt.Sprintf("payload build failed: %s", errDetails))
		}

		// Wait before polling again
		time.Sleep(2 * time.Second)
	}

	return WrapError("WaitForPayloadComplete", ErrTimeout, "timeout waiting for payload to complete")
}

// DownloadPayload downloads the payload binary.
func (c *Client) DownloadPayload(ctx context.Context, uuid string) ([]byte, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	if uuid == "" {
		return nil, WrapError("DownloadPayload", ErrInvalidInput, "UUID is required")
	}

	// Construct download URL
	scheme := "https"
	if !c.config.SSL {
		scheme = "http"
	}
	downloadURL := fmt.Sprintf("%s://%s/direct/download/%s", scheme, stripScheme(c.config.ServerURL), uuid)

	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", downloadURL, nil)
	if err != nil {
		return nil, WrapError("DownloadPayload", err, "failed to create request")
	}

	// Add authentication headers
	headers := c.getAuthHeaders()
	for key, value := range headers {
		req.Header.Set(key, value)
	}

	// Execute request
	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, WrapError("DownloadPayload", err, "failed to download payload")
	}
	defer resp.Body.Close() //nolint:errcheck // Response body close error not critical

	if resp.StatusCode != http.StatusOK {
		body, readErr := io.ReadAll(resp.Body)
		errMsg := fmt.Sprintf("HTTP %d", resp.StatusCode)
		if readErr == nil && len(body) > 0 {
			errMsg = fmt.Sprintf("HTTP %d: %s", resp.StatusCode, string(body))
		}
		return nil, WrapError("DownloadPayload", ErrInvalidResponse, errMsg)
	}

	// Read payload data
	data, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, WrapError("DownloadPayload", err, "failed to read payload data")
	}

	return data, nil
}

package mythic

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/nbaertsch/mythic-sdk-go/pkg/mythic/types"
)

// GetResponsesByTask retrieves all responses for a specific task.
//
// Task responses contain the actual output generated by command execution.
// A single task may have multiple response entries as output is streamed.
//
// Parameters:
//   - ctx: Context for cancellation and timeout
//   - taskID: ID of the task to retrieve responses for
//
// Returns:
//   - []*types.Response: Ordered list of responses (earliest first)
//   - error: Error if task ID is invalid or query fails
//
// Example:
//
//	responses, err := client.GetResponsesByTask(ctx, 42)
//	if err != nil {
//	    return err
//	}
//	for _, resp := range responses {
//	    fmt.Printf("Response %d: %s\n", resp.ID, resp.Response)
//	}
func (c *Client) GetResponsesByTask(ctx context.Context, taskID int) ([]*types.Response, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	if taskID == 0 {
		return nil, WrapError("GetResponsesByTask", ErrInvalidInput, "task ID is required")
	}

	var query struct {
		Response []struct {
			ID             int    `graphql:"id"`
			Response       string `graphql:"response_text"`
			Timestamp      string `graphql:"timestamp"`
			TaskID         int    `graphql:"task_id"`
			SequenceNumber *int   `graphql:"sequence_number"`
		} `graphql:"response(where: {task_id: {_eq: $task_id}}, order_by: {id: asc})"`
	}

	variables := map[string]interface{}{
		"task_id": taskID,
	}

	err := c.executeQuery(ctx, &query, variables)
	if err != nil {
		return nil, WrapError("GetResponsesByTask", err, "failed to query responses")
	}

	responses := make([]*types.Response, len(query.Response))
	for i, resp := range query.Response {
		// Parse timestamp - Mythic v3.4.20 returns timestamps without timezone
		timestamp, err := parseTimestamp(resp.Timestamp)
		if err != nil {
			timestamp = time.Time{}
		}

		responses[i] = &types.Response{
			ID:             resp.ID,
			Response:       resp.Response,
			Timestamp:      timestamp,
			TaskID:         resp.TaskID,
			SequenceNumber: resp.SequenceNumber,
		}
	}

	return responses, nil
}

// GetResponseByID retrieves a specific response by its ID.
//
// Parameters:
//   - ctx: Context for cancellation and timeout
//   - responseID: ID of the response to retrieve
//
// Returns:
//   - *types.Response: The response object
//   - error: Error if response ID is invalid or not found
//
// Example:
//
//	response, err := client.GetResponseByID(ctx, 123)
//	if err != nil {
//	    return err
//	}
//	fmt.Printf("Response: %s\n", response.Response)
func (c *Client) GetResponseByID(ctx context.Context, responseID int) (*types.Response, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	if responseID == 0 {
		return nil, WrapError("GetResponseByID", ErrInvalidInput, "response ID is required")
	}

	var query struct {
		Response []struct {
			ID             int    `graphql:"id"`
			Response       string `graphql:"response_text"`
			Timestamp      string `graphql:"timestamp"`
			TaskID         int    `graphql:"task_id"`
			SequenceNumber *int   `graphql:"sequence_number"`
			Task           struct {
				ID          int    `graphql:"id"`
				CommandName string `graphql:"command_name"`
				Status      string `graphql:"status"`
				CallbackID  int    `graphql:"callback_id"`
			} `graphql:"task"`
		} `graphql:"response(where: {id: {_eq: $response_id}})"`
	}

	variables := map[string]interface{}{
		"response_id": responseID,
	}

	err := c.executeQuery(ctx, &query, variables)
	if err != nil {
		return nil, WrapError("GetResponseByID", err, "failed to query response")
	}

	if len(query.Response) == 0 {
		return nil, WrapError("GetResponseByID", ErrNotFound, fmt.Sprintf("response %d not found", responseID))
	}

	resp := query.Response[0]
	// Parse timestamp - Mythic v3.4.20 returns timestamps without timezone
	timestamp, err := parseTimestamp(resp.Timestamp)
	if err != nil {
		timestamp = time.Time{}
	}

	return &types.Response{
		ID:             resp.ID,
		Response:       resp.Response,
		Timestamp:      timestamp,
		TaskID:         resp.TaskID,
		SequenceNumber: resp.SequenceNumber,
		TaskCommand:    resp.Task.CommandName,
		TaskStatus:     resp.Task.Status,
		TaskCallbackID: resp.Task.CallbackID,
	}, nil
}

// GetResponsesByCallback retrieves recent responses from a specific callback.
//
// This is useful for monitoring output from a specific agent in real-time.
//
// Parameters:
//   - ctx: Context for cancellation and timeout
//   - callbackID: ID of the callback to retrieve responses from
//   - limit: Maximum number of responses to return (0 for default: 100)
//
// Returns:
//   - []*types.Response: List of responses (most recent first)
//   - error: Error if callback ID is invalid or query fails
//
// Example:
//
//	// Get last 50 responses from callback
//	responses, err := client.GetResponsesByCallback(ctx, 5, 50)
//	if err != nil {
//	    return err
//	}
//	for _, resp := range responses {
//	    fmt.Printf("[%s] %s\n", resp.Timestamp, resp.Response)
//	}
func (c *Client) GetResponsesByCallback(ctx context.Context, callbackID int, limit int) ([]*types.Response, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	if callbackID == 0 {
		return nil, WrapError("GetResponsesByCallback", ErrInvalidInput, "callback ID is required")
	}

	if limit <= 0 {
		limit = 100 // Default limit
	}

	var query struct {
		Response []struct {
			ID             int    `graphql:"id"`
			Response       string `graphql:"response_text"`
			Timestamp      string `graphql:"timestamp"`
			TaskID         int    `graphql:"task_id"`
			SequenceNumber *int   `graphql:"sequence_number"`
			Task           struct {
				ID          int    `graphql:"id"`
				CommandName string `graphql:"command_name"`
			} `graphql:"task"`
		} `graphql:"response(where: {task: {callback_id: {_eq: $callback_id}}}, order_by: {timestamp: desc}, limit: $limit)"`
	}

	variables := map[string]interface{}{
		"callback_id": callbackID,
		"limit":       limit,
	}

	err := c.executeQuery(ctx, &query, variables)
	if err != nil {
		return nil, WrapError("GetResponsesByCallback", err, "failed to query responses")
	}

	responses := make([]*types.Response, len(query.Response))
	for i, resp := range query.Response {
		// Parse timestamp - Mythic v3.4.20 returns timestamps without timezone
		timestamp, err := parseTimestamp(resp.Timestamp)
		if err != nil {
			timestamp = time.Time{}
		}

		responses[i] = &types.Response{
			ID:             resp.ID,
			Response:       resp.Response,
			Timestamp:      timestamp,
			TaskID:         resp.TaskID,
			SequenceNumber: resp.SequenceNumber,
			TaskCommand:    resp.Task.CommandName,
		}
	}

	return responses, nil
}

// SearchResponses performs full-text search across task responses.
//
// This allows finding specific output patterns, commands, or data across
// all responses in the operation. Useful for hunting credentials, paths,
// or other IOCs in command output.
//
// Note: This is a simplified implementation that fetches responses and
// filters them client-side. For large datasets, consider using more
// specific filtering (GetResponsesByCallback, GetResponsesByTask, etc.)
//
// Parameters:
//   - ctx: Context for cancellation and timeout
//   - req: Search request with query string and filters
//
// Returns:
//   - []*types.Response: Matching responses
//   - error: Error if search request is invalid or query fails
//
// Example:
//
//	// Search for responses containing "Administrator"
//	req := &types.ResponseSearchRequest{
//	    Query: "Administrator",
//	    OperationID: &operationID,
//	    Limit: 50,
//	}
//	responses, err := client.SearchResponses(ctx, req)
//	if err != nil {
//	    return err
//	}
//	for _, resp := range responses {
//	    fmt.Printf("Task %d: %s\n", resp.TaskID, resp.Response)
//	}
func (c *Client) SearchResponses(ctx context.Context, req *types.ResponseSearchRequest) ([]*types.Response, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	if req == nil {
		return nil, WrapError("SearchResponses", ErrInvalidInput, "search request is required")
	}

	// Validate and set defaults
	if err := req.Validate(); err != nil {
		return nil, WrapError("SearchResponses", ErrInvalidInput, err.Error())
	}
	req.SetDefaults()

	// Determine which base query to use based on filters
	var allResponses []*types.Response
	var err error

	if req.TaskID != nil {
		// Most specific: search within a single task
		allResponses, err = c.GetResponsesByTask(ctx, *req.TaskID)
	} else if req.CallbackID != nil {
		// Search within a callback's responses
		fetchLimit := req.Limit * 5 // Fetch more since we'll filter
		if fetchLimit > 1000 {
			fetchLimit = 1000
		}
		allResponses, err = c.GetResponsesByCallback(ctx, *req.CallbackID, fetchLimit)
	} else if req.OperationID != nil {
		// Search across operation
		fetchLimit := req.Limit * 5
		if fetchLimit > 1000 {
			fetchLimit = 1000
		}
		allResponses, err = c.GetLatestResponses(ctx, *req.OperationID, fetchLimit)
	} else {
		// Default: search current operation
		fetchLimit := req.Limit * 5
		if fetchLimit > 1000 {
			fetchLimit = 1000
		}
		allResponses, err = c.GetLatestResponses(ctx, 0, fetchLimit)
	}

	if err != nil {
		return nil, WrapError("SearchResponses", err, "failed to fetch responses")
	}

	// Client-side filtering
	var filtered []*types.Response
	for _, resp := range allResponses {
		// Text search
		if req.Query != "" {
			if !strings.Contains(strings.ToLower(resp.Response), strings.ToLower(req.Query)) {
				continue
			}
		}

		// Time range filters
		if req.StartTime != nil && resp.Timestamp.Before(*req.StartTime) {
			continue
		}
		if req.EndTime != nil && resp.Timestamp.After(*req.EndTime) {
			continue
		}

		filtered = append(filtered, resp)

		// Stop if we've hit the limit
		if len(filtered) >= req.Limit+req.Offset {
			break
		}
	}

	// Apply pagination
	start := req.Offset
	if start > len(filtered) {
		start = len(filtered)
	}
	end := start + req.Limit
	if end > len(filtered) {
		end = len(filtered)
	}

	return filtered[start:end], nil
}

// GetLatestResponses retrieves the most recent responses across an operation.
//
// This provides a real-time feed of command output across all active callbacks.
//
// Parameters:
//   - ctx: Context for cancellation and timeout
//   - operationID: ID of the operation (0 for current operation)
//   - limit: Maximum number of responses to return (0 for default: 100)
//
// Returns:
//   - []*types.Response: Recent responses (most recent first)
//   - error: Error if operation ID is invalid or query fails
//
// Example:
//
//	// Get last 20 responses from current operation
//	responses, err := client.GetLatestResponses(ctx, 0, 20)
//	if err != nil {
//	    return err
//	}
//	for _, resp := range responses {
//	    fmt.Printf("[Callback %d] %s: %s\n",
//	        resp.Task.CallbackID, resp.Task.CommandName, resp.Response)
//	}
func (c *Client) GetLatestResponses(ctx context.Context, operationID int, limit int) ([]*types.Response, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	// Use current operation if not specified
	if operationID == 0 {
		currentOp := c.GetCurrentOperation()
		if currentOp == nil {
			return nil, WrapError("GetLatestResponses", ErrNotAuthenticated, "no current operation set")
		}
		operationID = *currentOp
	}

	if limit <= 0 {
		limit = 100 // Default limit
	}

	var query struct {
		Response []struct {
			ID             int    `graphql:"id"`
			Response       string `graphql:"response_text"`
			Timestamp      string `graphql:"timestamp"`
			TaskID         int    `graphql:"task_id"`
			SequenceNumber *int   `graphql:"sequence_number"`
			Task           struct {
				ID          int    `graphql:"id"`
				CommandName string `graphql:"command_name"`
				Status      string `graphql:"status"`
				CallbackID  int    `graphql:"callback_id"`
				Callback    struct {
					ID   int    `graphql:"id"`
					Host string `graphql:"host"`
					User string `graphql:"user"`
				} `graphql:"callback"`
			} `graphql:"task"`
		} `graphql:"response(where: {task: {operation_id: {_eq: $operation_id}}}, order_by: {timestamp: desc}, limit: $limit)"`
	}

	variables := map[string]interface{}{
		"operation_id": operationID,
		"limit":        limit,
	}

	err := c.executeQuery(ctx, &query, variables)
	if err != nil {
		return nil, WrapError("GetLatestResponses", err, "failed to query latest responses")
	}

	responses := make([]*types.Response, len(query.Response))
	for i, resp := range query.Response {
		// Parse timestamp - Mythic v3.4.20 returns timestamps without timezone
		timestamp, err := parseTimestamp(resp.Timestamp)
		if err != nil {
			timestamp = time.Time{}
		}

		responses[i] = &types.Response{
			ID:             resp.ID,
			Response:       resp.Response,
			Timestamp:      timestamp,
			TaskID:         resp.TaskID,
			SequenceNumber: resp.SequenceNumber,
			TaskCommand:    resp.Task.CommandName,
			TaskStatus:     resp.Task.Status,
			TaskCallbackID: resp.Task.CallbackID,
		}
	}

	return responses, nil
}

// GetResponseStatistics retrieves aggregated statistics for a task's responses.
//
// This provides metadata about response count, size, and timing without
// fetching the actual response content.
//
// Parameters:
//   - ctx: Context for cancellation and timeout
//   - taskID: ID of the task to get statistics for
//
// Returns:
//   - *types.ResponseStatistics: Aggregated statistics
//   - error: Error if task ID is invalid or query fails
//
// Example:
//
//	stats, err := client.GetResponseStatistics(ctx, 42)
//	if err != nil {
//	    return err
//	}
//	fmt.Printf("Task %d: %d responses, %d total bytes\n",
//	    stats.TaskID, stats.ResponseCount, stats.TotalSize)
func (c *Client) GetResponseStatistics(ctx context.Context, taskID int) (*types.ResponseStatistics, error) {
	if err := c.EnsureAuthenticated(ctx); err != nil {
		return nil, err
	}

	if taskID == 0 {
		return nil, WrapError("GetResponseStatistics", ErrInvalidInput, "task ID is required")
	}

	// First get task details
	var taskQuery struct {
		Task []struct {
			ID        int    `graphql:"id"`
			Status    string `graphql:"status"`
			Completed bool   `graphql:"completed"`
		} `graphql:"task(where: {id: {_eq: $task_id}})"`
	}

	variables := map[string]interface{}{
		"task_id": taskID,
	}

	err := c.executeQuery(ctx, &taskQuery, variables)
	if err != nil {
		return nil, WrapError("GetResponseStatistics", err, "failed to query task")
	}

	if len(taskQuery.Task) == 0 {
		return nil, WrapError("GetResponseStatistics", ErrNotFound, fmt.Sprintf("task %d not found", taskID))
	}

	// Get response statistics
	var responseQuery struct {
		Response []struct {
			ID        int    `graphql:"id"`
			Response  string `graphql:"response_text"`
			Timestamp string `graphql:"timestamp"`
		} `graphql:"response(where: {task_id: {_eq: $task_id}}, order_by: {timestamp: asc})"`
	}

	err = c.executeQuery(ctx, &responseQuery, variables)
	if err != nil {
		return nil, WrapError("GetResponseStatistics", err, "failed to query responses")
	}

	// Calculate statistics
	stats := &types.ResponseStatistics{
		TaskID:        taskID,
		ResponseCount: len(responseQuery.Response),
		TotalSize:     0,
		IsComplete:    taskQuery.Task[0].Completed,
	}

	if stats.ResponseCount > 0 {
		// Parse timestamps - Mythic v3.4.20 returns timestamps without timezone
		firstTimestamp, err := parseTimestamp(responseQuery.Response[0].Timestamp)
		if err != nil {
			firstTimestamp = time.Time{}
		}
		latestTimestamp, err := parseTimestamp(responseQuery.Response[len(responseQuery.Response)-1].Timestamp)
		if err != nil {
			latestTimestamp = time.Time{}
		}

		stats.FirstResponse = firstTimestamp
		stats.LatestResponse = latestTimestamp

		for _, resp := range responseQuery.Response {
			stats.TotalSize += len(resp.Response)
		}
	}

	return stats, nil
}
